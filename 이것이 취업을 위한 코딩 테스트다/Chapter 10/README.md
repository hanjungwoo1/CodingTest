# 그래프 이론

## 다양한 그래프 알고리즘
### 이미 배운 내용을 훑어보자
| |그래프|트리|
|-----|----|----|
|방향성|방향 그래프 혹은 무방향 그래프|방향 그래프|
|순환성|순환 및 비순환|비순환|
|루트노드 존재 여부|루트 노드가 없음|루트 노드가 존재|
|노드간 관계성|부모와 지식 관계 없음|부모와 자식 관계|
|모델의 종류|네트워크 모델|계층 모델|

   1. 그래프의 구현 방법
      1. 인접 행렬(Adjacency Matrix) : 2차원 배열을 사용하는 방식
      2. 인접 리스트(Adjacency List) : 리스트를 사용하는 방식
   2. 메모리와 시간을 염두
      1. 노드의 개수가 적은 경우에는 플로이드 워셜
      2. 노드와 간선의 개수가 많으면 우선순위 큐를 사용하는 다익스트라

### 서로소 집합
   1. 서로소 집합(Disjoint Sets) : 공통 원소가 없는 두 집합
   2. 서로소 집합 자료구조 : 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조
   3. union과 find 이 2개의 연산으로 조작

#### 서로소 집합 자료구조
   1. Union(합집합) 연산을 확인하여, 서로 연결된 두 노드 A, B를 확인한다
      - A와 B 루토 노드 A', B'를 각각 찾는다
      - A'를 B'의 부모 노드로 설정한다(B'가 A'를 가리키도록 한다)
   2. 모든 Union(합집합) 연산을 처리할 때 까지 1번 과정을 반복한다
   3. 10-1.py 기본적인 서로소 집합 알고리즘 소스코드
   4. 10-2.py 경로 압축 기법 소스코드

#### 서로소 집합 알고리즘의 시간 복잡도
   5. 10-3.py 개선된 서로소 집합 알고리즘 소스코드

#### 서로소 집합을 활용한 사이클 판별
   6. 10-4.py 서로소 집합을 활용한 사이클 판별 소스코드

### 신장 트리
   1. 신장 트리(Spanning Tree) : 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프

#### 크루스칼 알고리즘
   1. 도시들을 최소한의 비용으로 탐사 or 연결
   2. 크루스칼 알고리즘(Kruskal Algorithm)
      1. 간선 데이터를 비용에 따라 오름차순으로 정렬
      2. 간선을 하나씩 확인하며 현재의 간선이 사이클이 발생시키는지 확인
         1. 사이클이 발생하지 않는 경우 최소 신장 트리에 포함
         2. 사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않는다
      3. 모든 간선에 대해 2번 과정을 반복
   3. 10-5.py 크루스칼 알고리즘 소스코드

### 위상 정렬
   1. 위상 정렬(Topology Sort) : 순서가 정해져 있는 일련의 작업을 차례대로 수행해야할 때 사용하는 알고리즘
   2. 방향 그래프의 모든 노드를 '방향성에 거스르지 않도록 순서대로 나열하는 것'
      1. 진입차수가 0인 노드를 큐에 넣는다
      2. 큐가 빌 때까지 다음의 과정을 반복한다
         1. 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거
         2. 새롭게 진입차수가 0이 된 노드를 큐에 넣는다
   3. 10-6.py 위상 정렬 소스코드

#### 위상 정렬의 시간 복잡도
   1. 위상 정렬의 시간 복잡도는 O(V+E)

## 2. 팀 결성
   1. 서로소 집합 문제
   2. N과 M의 범위가 모두 최대 100,000이므로 경로 압축
   3. 10-7.py 답안 예시
